"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var sender_1 = require("../sender");
var jest_mock_1 = __importDefault(require("jest-mock"));
var ADS_123 = {
    id: '123',
    type: 'ads',
    pageView: 'pv1',
    inscreenTime: 0,
};
var ADS_123_UPDATED = {
    id: '123',
    type: 'ads',
    inscreenTime: 2300,
    pageView: 'pv1',
};
var ADS_555 = { id: '555', type: 'ads', pageView: 'pv1' };
var IMPR_456 = {
    id: '456',
    type: 'impression',
    pageView: 'pv1',
    inscreenTime: 400,
};
var IMPR_456_UPDATED = {
    id: '456',
    type: 'impression',
    pageView: 'pv1',
    inscreenTime: 600,
};
var IMPR_69346794 = {
    article: {
        harvesterId: 'localhost/69347371',
        url: '/nyheter/snoras-over-elva-driva-i-oppdal/69347371',
    },
    title: 'Snøras over elva Driva i Oppdal',
    id: '69347371',
    inscreenTime: 2645,
    pageView: 'ac592259-7c8a-4a8f-b15a-d71d5ac2a8f0',
    site: 'localhost',
    type: 'impression',
    userId: '0',
};
var IMPR_69346794_UPDATED = {
    article: {
        url: '/nyheter/snoras-over-elva-driva-i-oppdal/69347371',
        harvesterId: 'localhost/69347371',
    },
    title: 'Snøras over elva Driva i Oppdal',
    id: '69347371',
    inscreenTime: 8500,
    pageView: 'ac592259-7c8a-4a8f-b15a-d71d5ac2a8f0',
    site: 'localhost',
    type: 'impression',
    userId: 'ga-342',
};
var PAGELOAD_NO_ID = {
    id: 'www.dagbladet.no',
    type: 'pageLoad',
    pageView: 'pv1',
};
var IMPRESSION_NO_ID = {
    id: 'www.dagbladet.no',
    type: 'impression',
    pageView: 'pv1',
};
describe('Sender', function () {
    describe('scenarios', function () {
        it('should send the same data twice', function () {
            var mockSend = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                checkConsent: function () { return true; },
                pendingEvents: [],
                sentEvents: [],
                send: mockSend,
            });
            sender.sendWhenBefitting([IMPR_69346794, ADS_123]);
            sender.sendNow();
            expect(mockSend.mock.calls.length).toBe(1);
            sender.sendWhenBefitting([IMPR_69346794, ADS_123]);
            sender.sendNow();
            // We expect that the second sending worked as well
            expect(mockSend.mock.calls.length).toBe(2);
        });
        it('should send same event twice if event is updated', function () {
            var mockSend = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                pendingEvents: [],
                sentEvents: [IMPR_456],
                send: mockSend,
                checkConsent: function () { return true; },
            });
            sender.sendNow([IMPR_456_UPDATED]);
            expect(sender.sentEvents).toEqual([IMPR_456_UPDATED]);
            expect(mockSend.mock.calls[0][0]).toEqual([IMPR_456_UPDATED]);
        });
    });
    describe('sendNow', function () {
        it('should not send twice when called twice without adding pending data in between', function () {
            var mockSend = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                checkConsent: function () { return true; },
                send: mockSend,
                pendingEvents: [ADS_123],
                sentEvents: [],
            });
            sender.sendNow();
            sender.sendNow();
            sender.sendNow();
            expect(mockSend.mock.calls.length).toEqual(1);
        });
        it('should call the sendLink with one event in pending store', function () {
            var pendingEvents = [ADS_123];
            var mockSend = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: [],
                send: mockSend,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            expect(mockSend.mock.calls.length).toEqual(1);
            expect(mockSend.mock.calls[0][0]).toEqual([ADS_123]);
        });
        it('should call the sendLink with two events in pending store', function () {
            var pendingEvents = [ADS_123, IMPR_456];
            var mockSend = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: [],
                send: mockSend,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            expect(mockSend.mock.calls.length).toEqual(1);
            expect(mockSend.mock.calls[0][0]).toEqual([ADS_123, IMPR_456]);
        });
        it('should not call the sendLink with no events in pending store', function () {
            var pendingEvents = [];
            var mockSend = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: [],
                send: mockSend,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            expect(mockSend.mock.calls.length).toEqual(0);
        });
        it('should empty the pending store when sending one event', function () {
            var pendingEvents = [ADS_123];
            var send = function () { return null; };
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: [],
                send: send,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            expect(sender.pendingEvents).toEqual([]);
        });
        it('should empty the pending store when sending two events', function () {
            var pendingEvents = [ADS_123, IMPR_456];
            var send = function () { return null; };
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: [],
                send: send,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            expect(sender.pendingEvents).toEqual([]);
        });
        it('should add the previously pending to the sentEvents empty store when sending one event', function () {
            var pendingEvents = [ADS_123];
            var send = function () { return null; };
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: [],
                send: send,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            expect(sender.sentEvents).toEqual(pendingEvents);
        });
        it('should add the previously pending to the sentEvents empty store when sending two events', function () {
            var pendingEvents = [ADS_123, IMPR_456];
            var send = function () { return null; };
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: [],
                send: send,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            expect(sender.sentEvents).toEqual(pendingEvents);
        });
        it('should add the previously pending to the sentEvents store when other things are already sent', function () {
            var sentEvents = [IMPR_456];
            var pendingEvents = [ADS_123];
            var send = function () { return null; };
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: sentEvents,
                send: send,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            var result = sender.sentEvents;
            expect(result.length).toBe(2);
            expect(result).toContain(IMPR_456);
            expect(result).toContain(ADS_123);
        });
        it('should let pending and sent be unchanged when sending with no pending', function () {
            var sentEvents = [ADS_123];
            var pendingEvents = [];
            var send = function () { return null; };
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: sentEvents,
                send: send,
                checkConsent: function () { return true; },
            });
            sender.sendNow();
            expect(sender.sentEvents).toEqual(sentEvents);
            expect(sender.pendingEvents).toEqual(pendingEvents);
        });
        it('should send events directly', function () {
            var sentEvents = [ADS_123];
            var pendingEvents = [];
            var send = function () { return null; };
            var sender = new sender_1.TestableSender({
                pendingEvents: pendingEvents,
                sentEvents: sentEvents,
                send: send,
                checkConsent: function () { return true; },
            });
            sender.sendNow([IMPR_456]);
            expect(sender.sentEvents).toEqual([ADS_123, IMPR_456]);
            expect(sender.pendingEvents).toEqual([]);
        });
    });
    describe('sendWhenBefitting', function () {
        it('should add one to-be-sent event to pending', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [],
                sentEvents: [],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            var data = [ADS_123];
            sender.sendWhenBefitting(data);
            expect(sender.pendingEvents).toEqual(data);
        });
        it('should add two unique to-be-sent events to pending', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [],
                sentEvents: [],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            var data = [ADS_123, IMPR_456];
            sender.sendWhenBefitting(data);
            expect(sender.pendingEvents).toEqual(data);
        });
        it('should add one to-be-sent event to pending when something already pending', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [ADS_123],
                sentEvents: [],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([IMPR_456]);
            expect(sender.pendingEvents).toEqual([ADS_123, IMPR_456]);
        });
        it('should add two to-be-sent event to pending when something already pending', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [ADS_123],
                sentEvents: [],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([IMPR_456, ADS_555]);
            expect(sender.pendingEvents).toEqual([ADS_123, IMPR_456, ADS_555]);
        });
        it('should not add event to pending if it is already pending', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [ADS_123],
                sentEvents: [],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([ADS_123]);
            expect(sender.pendingEvents).toEqual([ADS_123]);
        });
        it('should add event to pending even if it is already sent', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [],
                sentEvents: [ADS_123],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([ADS_123]);
            expect(sender.pendingEvents).toEqual([ADS_123]);
        });
        it('should add all events to pending, including those that are already sent', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [],
                sentEvents: [IMPR_456],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([IMPR_456, ADS_123]);
            expect(sender.pendingEvents).toEqual([IMPR_456, ADS_123]);
        });
        it('should add event to pending even though older version is sent', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [ADS_123],
                sentEvents: [],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([ADS_123_UPDATED]);
            expect(sender.pendingEvents).toEqual([ADS_123_UPDATED]);
        });
        it('should add event to pending even though older version of object copy is sent', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [],
                sentEvents: [__assign({}, ADS_123)],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([ADS_123]);
            expect(sender.pendingEvents).toEqual([ADS_123]);
        });
        it('only stores the latest update of pending events', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [ADS_123],
                sentEvents: [],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([ADS_123_UPDATED]);
            expect(sender.pendingEvents).toEqual([ADS_123_UPDATED]);
        });
        it('should not add two impressions of same id to pending', function () {
            var sender = new sender_1.TestableSender({
                pendingEvents: [],
                sentEvents: [],
                send: jest_mock_1.default.fn(),
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([IMPR_69346794, IMPR_69346794_UPDATED]);
            expect(sender.pendingEvents).toEqual([IMPR_69346794_UPDATED]);
        });
        it('should not overwrite events in pendingStore that has the same id, if the event type is different', function () {
            var send = function () { return null; };
            var sender = new sender_1.TestableSender({
                pendingEvents: [PAGELOAD_NO_ID],
                sentEvents: [],
                send: send,
                checkConsent: function () { return true; },
            });
            sender.sendWhenBefitting([IMPRESSION_NO_ID]);
            expect(sender.pendingEvents).toEqual([PAGELOAD_NO_ID, IMPRESSION_NO_ID]);
        });
    });
    describe('sendNowIfAllowed', function () {
        it('should not send events if we do not have consent', function () {
            var sendFunc = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                pendingEvents: [ADS_123],
                sentEvents: [],
                send: sendFunc,
                checkConsent: function () { return false; },
            });
            sender.sendNowIfAllowed();
            expect(sendFunc.mock.calls.length).toBe(0);
            expect(sender.sentEvents).toEqual([]);
        });
        it('should not flush the store if we do not have consent', function () {
            var sendFunc = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                pendingEvents: [ADS_123],
                sentEvents: [],
                send: sendFunc,
                checkConsent: function () { return false; },
            });
            sender.sendNowIfAllowed();
            expect(sender.pendingEvents).toEqual([ADS_123]);
        });
        it('should send events if we do have consent', function () {
            var sendFunc = jest_mock_1.default.fn();
            var sender = new sender_1.TestableSender({
                pendingEvents: [IMPR_456],
                sentEvents: [ADS_123],
                send: sendFunc,
                checkConsent: function () { return true; },
            });
            sender.sendNowIfAllowed();
            expect(sender.pendingEvents).toEqual([]);
            expect(sender.sentEvents).toEqual([ADS_123, IMPR_456]);
            expect(sendFunc.mock.calls[0][0]).toEqual([IMPR_456]);
        });
    });
});
//# sourceMappingURL=sender.test.js.map