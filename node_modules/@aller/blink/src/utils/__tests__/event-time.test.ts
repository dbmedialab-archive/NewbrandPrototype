import { calculateEventTime, TimeEvent } from '../event-time';
import { ScreenEvent } from '../../reducers/screen';

describe('calculateEventTime', () => {
  it('should calculate the total', () => {
    const times: TimeEvent[] = [
      { type: 'start', time: new Date(0, 0, 0, 0, 0) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 1) },
    ];
    const inscreen = calculateEventTime({ times });
    expect(inscreen).toEqual(60000);
  });

  it('should merge duplicate events by picking the first one', () => {
    const times: TimeEvent[] = [
      { type: 'start', time: new Date(0, 0, 0, 0, 0) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 1) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 2) },
    ];
    const inscreen = calculateEventTime({ times });
    expect(inscreen).toEqual(60000 * 1);
  });

  it('should discard unrealistically high values', () => {
    const times: TimeEvent[] = [
      { type: 'start', time: new Date(0, 0, 0, 0, 0) },
      { type: 'stop', time: new Date(2017, 0, 0, 0, 0) },
    ];
    const inscreen = calculateEventTime({ times });
    expect(inscreen).toEqual(0);
  });

  it('should calculate the total for multiple intervals', () => {
    const times: TimeEvent[] = [
      // One second
      { type: 'start', time: new Date(0, 0, 0, 0, 0) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 1) }, // Another second
      { type: 'start', time: new Date(0, 0, 0, 0, 2) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 3) },
    ];
    const inscreen = calculateEventTime({ times });
    expect(inscreen).toEqual(60000 * 2);
  });

  it('should set inscreen to zero if no recorded times', () => {
    const times: TimeEvent[] = [];
    const inscreen = calculateEventTime({ times });
    expect(inscreen).toEqual(0);
  });

  it('should set inscreen to zero if only a stop time', () => {
    const times: TimeEvent[] = [
      { type: 'stop', time: new Date(0, 0, 0, 0, 1) },
    ];
    const inscreen = calculateEventTime({ times });
    expect(inscreen).toEqual(0);
  });

  it('should ignore the first event if it is a stop event', () => {
    const times: TimeEvent[] = [
      { type: 'stop', time: new Date(1000) },
      { type: 'start', time: new Date(2000) },
    ];
    const inscreen = calculateEventTime({
      times,
      now: new Date(4000),
    });
    expect(inscreen).toEqual(2000);
  });

  it('should use the current date if no end time to calculate total', () => {
    const times: TimeEvent[] = [{ type: 'start', time: new Date(0) }];
    const currentDate = new Date(1000);
    const inscreen = calculateEventTime({ times, now: currentDate });
    expect(inscreen).toEqual(1000);
  });

  it('should have a maximum idle time if no stop events registered', () => {
    const times: TimeEvent[] = [{ type: 'start', time: new Date(1000) }];
    const currentDate = new Date(40000);
    const inscreen = calculateEventTime({
      times,
      now: currentDate,
      maxIdleTime: 10000,
    });
    expect(inscreen).toEqual(10000);
  });

  it('should consider consecutive start times as a pulse', () => {
    const times: TimeEvent[] = [
      { type: 'start', time: new Date(1000) },
      { type: 'start', time: new Date(3000) },
    ];
    const currentDate = new Date(50000);
    const inscreen = calculateEventTime({
      times,
      now: currentDate,
      maxIdleTime: 10000,
    });
    expect(inscreen).toEqual(12000);
  });

  it('should conevert a page hide to a stop time', () => {
    const times: TimeEvent[] = [
      { type: 'start', time: new Date(0, 0, 0, 0, 0) },
    ];
    const screenEvents: ScreenEvent[] = [
      { type: 'hide', time: new Date(0, 0, 0, 0, 2) },
    ];
    const currentDate = new Date(0, 0, 0, 0, 5);
    const inscreen = calculateEventTime({
      times,
      screenEvents,
      now: currentDate,
    });
    expect(inscreen).toEqual(120000);
  });

  it('should handle complex case', () => {
    const times: TimeEvent[] = [
      { type: 'start', time: new Date(0, 0, 0, 0, 0) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 2) },
      { type: 'start', time: new Date(0, 0, 0, 0, 4) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 6) },
    ];
    const screenEvents: ScreenEvent[] = [
      { type: 'show', time: new Date(0, 0, 0, 0, 1) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 3) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 5) },
      { type: 'show', time: new Date(0, 0, 0, 0, 7) },
    ];
    const currentDate = new Date(0, 0, 0, 0, 20);
    const inscreen = calculateEventTime({
      times,
      screenEvents,
      now: currentDate,
    });
    expect(inscreen).toEqual(180000);
  });

  it('should case where the showing and hiding of the page controls the inscreen time', () => {
    const times: TimeEvent[] = [
      { type: 'start', time: new Date(0, 0, 0, 0, 0) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 20) },
    ];
    const screenEvents: ScreenEvent[] = [
      { type: 'show', time: new Date(0, 0, 0, 0, 1) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 3) },
      { type: 'show', time: new Date(0, 0, 0, 0, 5) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 7) },
      { type: 'show', time: new Date(0, 0, 0, 0, 14) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 16) },
    ];
    const currentDate = new Date(0, 0, 0, 0, 20);
    const inscreen = calculateEventTime({
      times,
      screenEvents,
      now: currentDate,
    });
    expect(inscreen).toEqual(420000);
  });

  it('should support a completely illogical series of events', () => {
    const times: TimeEvent[] = [
      { type: 'stop', time: new Date(0, 0, 0, 0, 0) },
      { type: 'start', time: new Date(0, 0, 0, 0, 2) },
      { type: 'start', time: new Date(0, 0, 0, 0, 2) },
      { type: 'start', time: new Date(0, 0, 0, 0, 2) },
      { type: 'start', time: new Date(0, 0, 0, 0, 3) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 19) },
      { type: 'stop', time: new Date(0, 0, 0, 0, 20) },
    ];
    const screenEvents: ScreenEvent[] = [
      { type: 'show', time: new Date(0, 0, 0, 0, 1) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 4) },
      { type: 'show', time: new Date(0, 0, 0, 0, 5) },
      { type: 'show', time: new Date(0, 0, 0, 0, 5) },
      { type: 'show', time: new Date(0, 0, 0, 0, 5) },
      { type: 'show', time: new Date(0, 0, 0, 0, 5) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 7) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 8) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 9) },
      { type: 'show', time: new Date(0, 0, 0, 0, 14) },
      { type: 'hide', time: new Date(0, 0, 0, 0, 16) },
    ];
    const currentDate = new Date(0, 0, 0, 0, 20);
    const inscreen = calculateEventTime({
      times,
      screenEvents,
      now: currentDate,
    });
    expect(inscreen).toEqual(360000);
  });
});
