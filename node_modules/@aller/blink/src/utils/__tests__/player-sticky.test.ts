import { VideoWatchEvent } from '../video-event-time';
import { PlayerStickyEvent, PlayerState } from '../../reducers/player';
import { modifyEventArrayWithStickyInfo } from '../player-sticky';

const videowatches: VideoWatchEvent[] = [
  {
    watchTime: 60000,
    startEvent: {
      type: 'start',
      videoId: 'test-video-id',
      reason: 'autostart',
      muted: true,
      position: 0,
      volume: 50,
      time: new Date(0, 0, 0, 0, 0),
      playerId: 'testPlayer',
    },
    stopEvent: {
      type: 'hidden',
      time: new Date(0, 0, 0, 0, 1),
      reason: 'tabclose',
      muted: true,
      position: 90,
      volume: 10,
    },
  },
  {
    watchTime: 60000,
    startEvent: {
      type: 'shown',
      time: new Date(0, 0, 0, 0, 4),
      reason: 'tabactive',
      muted: false,
      position: 90,
      volume: 10,
    },
    stopEvent: {
      type: 'stop',
      time: new Date(0, 0, 0, 0, 5),
      videoId: 'test-video-id',
      reason: 'pause',
      muted: true,
      position: 90,
      volume: 10,
      playerId: 'testPlayer',
    },
  },
];

describe('playerSticky', () => {
  it('no sticky events will produce `sticky: false` in videoWatch `stop event`', () => {
    const playerState: PlayerState = {
      testPlayer: [],
    };

    const expected: VideoWatchEvent[] = [
      {
        watchTime: 60000,
        startEvent: {
          type: 'start',
          videoId: 'test-video-id',
          reason: 'autostart',
          muted: true,
          position: 0,
          volume: 50,
          time: new Date(0, 0, 0, 0, 0),
          playerId: 'testPlayer',
        },
        stopEvent: {
          type: 'hidden',
          time: new Date(0, 0, 0, 0, 1),
          reason: 'tabclose',
          muted: true,
          position: 90,
          volume: 10,
          sticky: false,
        },
      },
      {
        watchTime: 60000,
        startEvent: {
          type: 'shown',
          time: new Date(0, 0, 0, 0, 4),
          reason: 'tabactive',
          muted: false,
          position: 90,
          volume: 10,
        },
        stopEvent: {
          type: 'stop',
          time: new Date(0, 0, 0, 0, 5),
          videoId: 'test-video-id',
          reason: 'pause',
          muted: true,
          position: 90,
          volume: 10,
          playerId: 'testPlayer',
          sticky: false,
        },
      },
    ];

    const actual = modifyEventArrayWithStickyInfo(
      'testPlayer',
      playerState,
      videowatches,
    );

    expect(actual).toEqual(expected);
  });

  it('if player became sticky (last sticky event has sticky: true prop)', () => {
    const stickyEvents: PlayerStickyEvent[] = [
      {
        type: 'sticky',
        sticky: true,
        closed: false,
        time: new Date(0, 0, 0, 0, 2),
        muted: false,
        volume: 0,
        position: 90,
      },
    ];

    const playerState: PlayerState = {
      testPlayer: stickyEvents,
    };

    const expected: VideoWatchEvent[] = [
      {
        watchTime: 60000,
        startEvent: {
          type: 'start',
          videoId: 'test-video-id',
          reason: 'autostart',
          muted: true,
          position: 0,
          volume: 50,
          time: new Date(0, 0, 0, 0, 0),
          playerId: 'testPlayer',
        },
        stopEvent: {
          type: 'hidden',
          time: new Date(0, 0, 0, 0, 1),
          reason: 'tabclose',
          muted: true,
          position: 90,
          volume: 10,
          sticky: false,
        },
      },
      {
        watchTime: 60000,
        startEvent: {
          type: 'shown',
          time: new Date(0, 0, 0, 0, 4),
          reason: 'tabactive',
          muted: false,
          position: 90,
          volume: 10,
        },
        stopEvent: {
          type: 'stop',
          time: new Date(0, 0, 0, 0, 5),
          videoId: 'test-video-id',
          reason: 'pause',
          muted: true,
          position: 90,
          volume: 10,
          playerId: 'testPlayer',
          sticky: true,
        },
      },
    ];

    // first watch event's stop is earlier than sticky event, so sticky info should not be initialized
    // second watch event has stop is later than sticky event, so it should be marked
    const actual = modifyEventArrayWithStickyInfo(
      'testPlayer',
      playerState,
      videowatches,
    );

    expect(actual).toEqual(expected);
  });

  it('if player became non-sticky (last sticky event has sticky: false prop)', () => {
    const stickyEvents: PlayerStickyEvent[] = [
      {
        type: 'sticky',
        sticky: true,
        closed: false,
        time: new Date(0, 0, 0, 0, 2),
        muted: false,
        volume: 0,
        position: 90,
      },
      {
        type: 'sticky',
        sticky: false,
        closed: false,
        time: new Date(0, 0, 0, 0, 3),
        muted: false,
        volume: 0,
        position: 90,
      },
    ];

    const playerState: PlayerState = {
      testPlayer: stickyEvents,
    };

    const expected: VideoWatchEvent[] = [
      {
        watchTime: 60000,
        startEvent: {
          type: 'start',
          videoId: 'test-video-id',
          reason: 'autostart',
          muted: true,
          position: 0,
          volume: 50,
          time: new Date(0, 0, 0, 0, 0),
          playerId: 'testPlayer',
        },
        stopEvent: {
          type: 'hidden',
          time: new Date(0, 0, 0, 0, 1),
          reason: 'tabclose',
          muted: true,
          position: 90,
          volume: 10,
          sticky: false,
        },
      },
      {
        watchTime: 60000,
        startEvent: {
          type: 'shown',
          time: new Date(0, 0, 0, 0, 4),
          reason: 'tabactive',
          muted: false,
          position: 90,
          volume: 10,
        },
        stopEvent: {
          type: 'stop',
          time: new Date(0, 0, 0, 0, 5),
          videoId: 'test-video-id',
          reason: 'pause',
          muted: true,
          position: 90,
          volume: 10,
          playerId: 'testPlayer',
          sticky: false,
        },
      },
    ];

    // first watch event should be marked as sticky
    // second watch event has stop is later than sticky event with sticky: false, so it should not be marked
    const actual = modifyEventArrayWithStickyInfo(
      'testPlayer',
      playerState,
      videowatches,
    );

    expect(actual).toEqual(expected);
  });

  it('if player sticky widget is closed (last sticky event have closed: true), next stop will have reason `stickyClosed`', () => {
    const stickyEvents: PlayerStickyEvent[] = [
      {
        type: 'sticky',
        sticky: false,
        closed: true,
        time: new Date(0, 0, 0, 0, 3),
        muted: false,
        volume: 0,
        position: 90,
      },
    ];

    const playerState: PlayerState = {
      testPlayer: stickyEvents,
    };

    const expected: VideoWatchEvent[] = [
      {
        watchTime: 60000,
        startEvent: {
          type: 'start',
          videoId: 'test-video-id',
          reason: 'autostart',
          muted: true,
          position: 0,
          volume: 50,
          time: new Date(0, 0, 0, 0, 0),
          playerId: 'testPlayer',
        },
        stopEvent: {
          type: 'hidden',
          time: new Date(0, 0, 0, 0, 1),
          reason: 'tabclose',
          muted: true,
          position: 90,
          volume: 10,
          sticky: false,
        },
      },
      {
        watchTime: 60000,
        startEvent: {
          type: 'shown',
          time: new Date(0, 0, 0, 0, 4),
          reason: 'tabactive',
          muted: false,
          position: 90,
          volume: 10,
        },
        stopEvent: {
          type: 'stop',
          time: new Date(0, 0, 0, 0, 5),
          videoId: 'test-video-id',
          reason: 'stickyClosed',
          muted: true,
          position: 90,
          volume: 10,
          playerId: 'testPlayer',
          sticky: false,
        },
      },
    ];

    // first watch event triggered when sticky event was not triggered, so sticy: false for him
    const actual = modifyEventArrayWithStickyInfo(
      'testPlayer',
      playerState,
      videowatches,
    );

    expect(actual).toEqual(expected);
  });
});
