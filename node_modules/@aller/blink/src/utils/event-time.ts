import { ScreenEvent } from '../reducers/screen';

export interface TimeEvent {
  type: 'start' | 'stop' | 'show' | 'hide';
  time: Date;
}

type ScreenTimeEvent = ScreenEvent | TimeEvent;

/**
 * Checks if there is a stop time present.
 */
export function hasFinalStopTime(times: TimeEvent[]) {
  const lastTime = times[times.length - 1];
  return !times.length || (lastTime && lastTime.type === 'stop');
}

/**
 * Skips duplicate start and end times. Could occur if
 * the machine has a hick-up when updating the inscreen time.
 *
 *  [ { start 1 }, { start 2 }, { end 1 } ]
 * Would be converted to:
 *  [ { start 1 }, { end 1 } ]
 */
function mergeDuplicateTimesTogether(times: TimeEvent[]) {
  return times.filter(({ type }, index) => {
    const prevTime = times[index - 1];
    const prevTimeIsADuplicate = prevTime && type === prevTime.type;
    return !prevTimeIsADuplicate;
  });
}

function integrateScreenEvents(times: TimeEvent[], screenEvents: TimeEvent[]) {
  const allTimes: TimeEvent[] = times
    .concat(screenEvents)
    .sort((a, b) => a.time.getTime() - b.time.getTime());

  return allTimes.filter((current, index) => {
    const prev = allTimes[index - 1];
    const prevType = prev ? prev.type : 'none';

    // Remove stop after hide
    if (prevType === 'hide' && current.type === 'stop') {
      return false;
    }
    // Remove show after start
    if (prevType === 'start' && current.type === 'show') {
      return false;
    }

    // Only accept start event as event after stop
    if (
      prevType === 'stop' &&
      (current.type === 'hide' || current.type === 'show')
    ) {
      return false;
    }
    return true;
  });
}

function convertScreenToTimeEvents(times: ScreenTimeEvent[]): TimeEvent[] {
  return times.map(timeEv => {
    if (timeEv.type === 'show') {
      const event: TimeEvent = {
        time: timeEv.time,
        type: 'start',
      };
      return event;
    }
    if (timeEv.type === 'hide') {
      const event: TimeEvent = {
        time: timeEv.time,
        type: 'stop',
      };
      return event;
    }
    return timeEv;
  });
}

/**
 * Removs a stop time if there is one at the beginning.
 * This can happen in some in-view libraries when the page
 * loads elements outside of the screen
 *
 *  [ {stop 1 }, { start 2 }, { stop 3 } ]
 * Would be converted to:
 *  [ { start 2 }, { stop 3 } ]
 */
function removeStopTimeAtBeginningIfPresent(times: TimeEvent[]) {
  if (times.length > 0 && times[0].type === 'stop') {
    return times.slice(1);
  }
  return times;
}

/**
 * Appends a stop time if there is no end to the tracking.
 * This can happen if a user closes her browser while an
 * impression is inscreen.
 *
 *  [ { start 1 } ]
 * Would be converted to:
 *  [ { start 1 }, { end 1 } ]
 */
function appendStopTimeIfNotPresent(
  times: TimeEvent[],
  now = new Date(),
  maxIdleTime: number,
) {
  if (!(now instanceof Date)) {
    throw Error('Now must be of the Date type. Are you mapping?');
  }

  if (hasFinalStopTime(times)) {
    return times;
  }
  const lastTimeEvent = times[times.length - 1];
  const maxTime = lastTimeEvent
    ? new Date(lastTimeEvent.time.getTime() + maxIdleTime)
    : now;
  // Add a stop event with whichever is smaller: the maxTime or current time
  return times.concat([{ type: 'stop', time: maxTime < now ? maxTime : now }]);
}

/**
 * Sets any values that are unrealistically high to zero.
 */
export function discardUnrealisticallyHighInscreen(inscreenTime: number) {
  const twoHours = 2 * 60 * 60 * 1000;
  return inscreenTime < twoHours ? inscreenTime : 0;
}

/**
 * Adds together all the intervals that were recorded
 * while an impression was inscreen.
 */
function sumStartAndStopTimes(times: TimeEvent[]): number {
  return times.reduce((total, { type, time }) => {
    if (type === 'start') {
      return total - time.getTime();
    }
    return total + time.getTime();
  }, 0);
}

export interface EventTimeInput {
  times: TimeEvent[];
  screenEvents?: ScreenEvent[];
  now?: Date;
  maxIdleTime?: number;
}

/**
 * Calculates the total inscreen time in milliseconds from
 * a list of start and end times.
 */
export function calculateEventTime(input: EventTimeInput) {
  if (!input.times || input.times.length === 0) {
    return 0;
  }

  let times: ScreenTimeEvent[] = integrateScreenEvents(
    input.times,
    input.screenEvents || [],
  );
  times = convertScreenToTimeEvents(times);
  times = appendStopTimeIfNotPresent(
    times,
    input.now || new Date(),
    input.maxIdleTime || 10000,
  );
  times = mergeDuplicateTimesTogether(times);
  const cleanedInterval = removeStopTimeAtBeginningIfPresent(times);
  const summedInterval = sumStartAndStopTimes(cleanedInterval);
  const positiveInterval = Math.max(0, summedInterval);
  const realisticInterval = discardUnrealisticallyHighInscreen(
    positiveInterval,
  );
  return realisticInterval;
}
