import { PlayerState, PlayerStickyEvent } from '../reducers/player';
import { VideoWatchEvent } from './video-event-time';
import { byTime } from './sort';

/**
 * @function processSticky
 * @returns array of videowatch events with filled data
 * about player stickiness (if it's minimized or not)
 */
export function modifyEventArrayWithStickyInfo(
  playerId: string,
  players: PlayerState,
  videoWatches: VideoWatchEvent[],
): VideoWatchEvent[] {
  const playerEvents = players[playerId] || [];
  const stickyEvents: any = playerEvents
    .filter(e => e.type === 'sticky')
    .sort(byTime);

  return videoWatches.map(v =>
    modifyEventWithStickyInfo(v, stickyEvents, videoWatches),
  );
}

function modifyEventWithStickyInfo(
  currentVideoWatch: VideoWatchEvent,
  stickyEvents: PlayerStickyEvent[],
  videoWatches: VideoWatchEvent[],
): VideoWatchEvent {
  const stopEvent = Object.assign({}, currentVideoWatch.stopEvent);
  const previousSticky = stickyEvents.filter(
    (s: PlayerStickyEvent) => s.time.getTime() <= stopEvent.time.getTime(),
  );
  const lastStickyEvent = previousSticky[previousSticky.length - 1];

  if (lastStickyEvent) {
    stopEvent.sticky = lastStickyEvent.sticky;

    if (lastStickyEvent.closed) {
      const alreadyBeenStopped = playerAlreadyHasBeenStopped(
        videoWatches,
        lastStickyEvent,
        currentVideoWatch,
      );

      if (!alreadyBeenStopped) {
        stopEvent.reason = 'stickyClosed';
      }
    }
  } else {
    stopEvent.sticky = false;
  }

  return {
    ...currentVideoWatch,
    stopEvent,
  };
}

/**
 * @function playerAlreadyHasBeenStopped
 * @returns if player already has been stopped previously,
 * after firing 'sticky closed' event,
 * trying to find video stop event earlier than current event
 * but later then last sticky event, because
 * we want to send 'stickyClosed' reason only for first stop event
 */
function playerAlreadyHasBeenStopped(
  videoWatches: VideoWatchEvent[],
  lastStickyEvent: PlayerStickyEvent,
  v: VideoWatchEvent,
): boolean {
  const currentStopTime = v.stopEvent.time.getTime();
  const lastStickyEventTime = lastStickyEvent.time.getTime();

  return videoWatches.some(f => {
    return (
      f.stopEvent.time.getTime() > lastStickyEventTime &&
      f.stopEvent.time.getTime() < currentStopTime
    );
  });
}
